'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	var extraNamespaceCount = void 0;
	var firstDefineNamespaced = void 0;

	var namespaceVisitor = {
		Identifier: function Identifier(path) {
			if (path.node.name === 'define') {
				if (path.parent.type === 'MemberExpression' && path.parent.property === path.node) {
					return;
				}

				if (path.parent.type === 'ObjectProperty' && path.parent.key === path.node) {
					return;
				}

				var scope = void 0;

				// Find if 'define' is defined in any scope
				for (scope = path.scope; scope != null; scope = scope.parent) {
					if (scope.bindings.define || scope.globals.define) {
						break;
					}
				}

				if (scope == null || scope.parent == null && !scope.bindings.define) {
					// If 'define' is not defined in any scope namespace or
					// defined in the root scope as global...
					if (!firstDefineNamespaced) {
						// ...and it's its first appearance, namespace it
						var namespace = this.opts.namespace || 'Liferay.Loader';

						path.node.name = namespace + '.define';

						firstDefineNamespaced = true;
					} else {
						// ...and appeared before, record a new extra appearance
						extraNamespaceCount++;
					}
				}
			}
		}
	};

	return {
		visitor: {
			Program: {
				exit: function exit(path, state) {
					// We must traverse the AST again because the third party
					// transform-es2015-modules-amd emits its define() call after
					// Program exit :-(
					firstDefineNamespaced = false;
					extraNamespaceCount = 0;

					path.traverse(namespaceVisitor, { opts: state.opts });

					if (extraNamespaceCount > 0) {
						var _babelIpc$get = babelIpc.get(state, function () {
							return {
								log: new _pluginLogger2.default()
							};
						}),
						    log = _babelIpc$get.log;

						if (firstDefineNamespaced) {
							log.info('namespace-amd-define', 'Namespaced first AMD define in file');
						}

						if (extraNamespaceCount) {
							log.warn('namespace-amd-define', 'Found', extraNamespaceCount, 'define() calls inside the module definition', 'which have been ignored as they should never', 'be executed during runtime');
						}
					}
				}
			}
		}
	};
};

var _babelIpc = require('liferay-npm-build-tools-common/lib/babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
//# sourceMappingURL=index.js.map