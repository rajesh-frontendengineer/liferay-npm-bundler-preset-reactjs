'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (_ref) {
	var t = _ref.types;

	var nameVisitor = {
		ExpressionStatement: function ExpressionStatement(path, state) {
			var expression = path.node.expression;
			var filenameRelative = state.file.opts.filenameRelative;
			var _state$opts = state.opts,
			    packageName = _state$opts.packageName,
			    srcPrefixes = _state$opts.srcPrefixes;
			var log = state.log;


			if (t.isCallExpression(expression)) {
				var callee = expression.callee;


				if (t.isIdentifier(callee, { name: 'define' })) {
					var args = expression.arguments;


					var insertName = false;
					var unshiftName = true;

					switch (args.length) {
						case 1:
							insertName = t.isFunctionExpression(args[0]);
							break;

						case 2:
							insertName = t.isArrayExpression(args[0]) && t.isFunctionExpression(args[1]);
							break;

						case 3:
							unshiftName = false;
							insertName = t.isStringLiteral(args[0]) && t.isArrayExpression(args[1]) && t.isFunctionExpression(args[2]);
							break;

						default:
							throw new Error('Unexpected argument count of ' + args.length);
					}

					if (insertName) {
						var normalizedPackageName = normalizePackageName(packageName, filenameRelative);

						var moduleName = getModuleName(filenameRelative, normalizeSrcPrefixes(srcPrefixes));

						var fullModuleName = normalizedPackageName + moduleName;

						if (unshiftName) {
							args.unshift(t.stringLiteral(fullModuleName));
						} else {
							args[0].value = fullModuleName;
						}

						log.info('name-amd-modules', 'Set module name to \'' + fullModuleName + '\'');

						path.stop();
					}
				}
			}
		}
	};

	return {
		visitor: {
			Program: {
				enter: function enter(path, state) {
					var _babelIpc$get = babelIpc.get(state, function () {
						return {
							log: new _pluginLogger2.default()
						};
					}),
					    log = _babelIpc$get.log;

					state.log = log;
				},
				exit: function exit(path, state) {
					// We must traverse the AST again because the
					// transform-es2015-modules-amd plugin emits its define()
					// call after exiting Program node :-(
					path.traverse(nameVisitor, state);
				}
			}
		}
	};
};

var _babelIpc = require('liferay-npm-build-tools-common/lib/babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var pkgs = _interopRequireWildcard(_packages);

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Normalize the srcPrefixes Babel option adding a trailing path separator when
 * it is not present.
 * @param {Array} srcPrefixes the original srcPrefixes
 * @return {Array} the normalized srcPrefixes array (with native path
 *         separators)
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function normalizeSrcPrefixes(srcPrefixes) {
	srcPrefixes = srcPrefixes || ['src/main/resources/META-INF/resources'];

	return srcPrefixes.map(function (srcPrefix) {
		return _path2.default.normalize(srcPrefix);
	}).map(function (srcPrefix) {
		return srcPrefix.endsWith(_path2.default.sep) ? srcPrefix : srcPrefix + _path2.default.sep;
	});
}

/**
 * Normalize the package name of a JS module file.
 * @param {String} packageName a forced package name or '<package.json>' to get
 *		  the package name from the nearest ancestor package.json file
 * @param {String} filenameRelative the filenameRelative path as given by Babel
 *        compiler
 * @return {String} the package name (in 'pkg@version' format) ending with '/'
 */


/**
 * Valid babel plugin options are:
 *	  packageName: '<package.json>'
 *    srcPrefixes: ['src/main/resources/META-INF/resources']
 * @return {object} a babel visitor
 */
function normalizePackageName(packageName, filenameRelative) {
	packageName = packageName || '<package.json>';

	if (packageName === '<package.json>') {
		var pkgJsonPath = pkgs.getPackageJsonPath(filenameRelative);
		var pkgJson = (0, _readJsonSync2.default)(pkgJsonPath);

		packageName = pkgJson.name + '@' + pkgJson.version + '/';
	}

	if (!packageName.endsWith('/')) {
		packageName += '/';
	}

	return packageName;
}

/**
 * Get the module name of a JS module file given its path.
 * @param {String} filenameRelative the filenameRelative path as given by Babel
 *        compiler
 * @param {Array} srcPrefixes an array of source directories where JS module
 *        files may live
 * @return {String} the module name that must be assigned to the file with the
 *         syntax:
 *         <package name>@<package version>/<relative path without trailing .js>
 */
function getModuleName(filenameRelative, srcPrefixes) {
	var filenameAbsolute = _path2.default.resolve(filenameRelative);
	var pkgDir = pkgs.getPackageDir(filenameRelative);

	var moduleName = filenameAbsolute.substring(pkgDir.length + 1);

	if (moduleName.toLowerCase().endsWith('.js')) {
		moduleName = moduleName.substring(0, moduleName.length - 3);
	}

	for (var i = 0; i < srcPrefixes.length; i++) {
		var srcPrefix = _path2.default.normalize(srcPrefixes[i]);

		if (moduleName.startsWith(srcPrefix)) {
			moduleName = moduleName.substring(srcPrefix.length);
			break;
		}
	}

	if (_path2.default.sep == '\\') {
		moduleName = moduleName.replace(/\\/g, '/');
	}

	return moduleName;
}
//# sourceMappingURL=index.js.map