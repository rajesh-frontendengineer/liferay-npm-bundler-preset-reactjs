'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (_ref) {
	var t = _ref.types;

	var wrapVisitor = {
		Identifier: function Identifier(path, _ref2) {
			var dependencies = _ref2.dependencies;

			var node = path.node;

			if (node.name === 'require') {
				var parent = path.parent;

				if (t.isCallExpression(parent) && parent.callee === node && parent.arguments.length == 1) {
					var argument0 = parent.arguments[0];

					if (t.isLiteral(argument0)) {
						var moduleName = argument0.value;

						dependencies[moduleName] = moduleName;
					}
				}
			}
		}
	};

	return {
		visitor: {
			Program: {
				enter: function enter(path, state) {
					state.dependencies = {};
				},
				exit: function exit(path, state) {
					var opts = state.opts,
					    file = state.file;
					var dependencies = state.dependencies;

					var _babelIpc$get = babelIpc.get(state, function () {
						return {
							log: new _pluginLogger2.default()
						};
					}),
					    log = _babelIpc$get.log;

					// We must traverse the AST again because some plugins emit
					// their require() calls after exiting Program node :-(


					path.traverse(wrapVisitor, { opts: opts, dependencies: dependencies });

					var node = path.node;
					var body = node.body;


					dependencies = Object.keys(dependencies).map(function (dep) {
						return '\'' + dep + '\'';
					});

					var buildDeps = (0, _babelTemplate2.default)('[\n                         \'module\', \'exports\', \'require\' \n                         ' + (dependencies.length > 0 ? ',' : '') + ' \n                         ' + dependencies.join() + '\n\t\t\t\t\t ]');

					var defineNode = buildDefine({
						SOURCE: body,
						DEPS: buildDeps()
					});

					defineNode = applyUserDefinedTemplateIfPresent(file.opts.filenameRelative, defineNode, log);

					if (!Array.isArray(defineNode)) {
						defineNode = [defineNode];
					}

					node.body = defineNode;

					if (dependencies.length == 0) {
						log.info('wrap-modules-amd', 'No dependencies detected');
					} else {
						log.info('wrap-modules-amd', 'Detected dependencies: ' + dependencies.join(', '));
					}
				}
			}
		}
	};
};

var _babelTemplate = require('babel-template');

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _babelIpc = require('liferay-npm-build-tools-common/lib/babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var buildDefine = (0, _babelTemplate2.default)('\n     define(DEPS, function(module, exports, require) {\n        // Make module believe it is running under Node.js\n        var define = undefined;\n \t    SOURCE\n     })\n ');

/**
 * @return {object} a babel visitor
 */


function applyUserDefinedTemplateIfPresent(filenameRelative, defineNode, log) {
	var templateFile = filenameRelative + '.wrap-modules-amd.template';

	if (!_fs2.default.existsSync(templateFile)) {
		return defineNode;
	}

	log.info('wrap-modules-amd', 'Applied user template to wrap file');

	var buildUserTemplate = (0, _babelTemplate2.default)(_fs2.default.readFileSync(templateFile).toString());

	_fs2.default.unlinkSync(templateFile);

	return buildUserTemplate({
		__WRAPPED_MODULE__: defineNode
	});
}
//# sourceMappingURL=index.js.map