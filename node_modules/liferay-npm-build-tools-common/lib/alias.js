"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadAliases = exports.getAliasToType = exports.getAliasFromType = exports.getAliasFields = exports.AliasToType = exports.AliasFromType = void 0;
const dot_prop_1 = __importDefault(require("dot-prop"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
var AliasFromType;
(function (AliasFromType) {
    AliasFromType[AliasFromType["EXTERNAL"] = 0] = "EXTERNAL";
    AliasFromType[AliasFromType["LOCAL"] = 1] = "LOCAL";
})(AliasFromType = exports.AliasFromType || (exports.AliasFromType = {}));
var AliasToType;
(function (AliasToType) {
    AliasToType[AliasToType["IGNORE"] = 0] = "IGNORE";
    AliasToType[AliasToType["EXTERNAL"] = 1] = "EXTERNAL";
    AliasToType[AliasToType["LOCAL"] = 2] = "LOCAL";
})(AliasToType = exports.AliasToType || (exports.AliasToType = {}));
const aliasesCache = Object.create(null);
/**
 * Get `resolve.aliasFields` configuration value.
 *
 * @remarks
 * The `resolve.aliasFields` name resembles the value webpack's configuration
 * uses for the same functionality (see
 * https://webpack.js.org/configuration/resolve/#resolvealiasfields)
 */
function getAliasFields(globalConfig, config) {
    let aliasFields;
    if (dot_prop_1.default.has(config, 'resolve.aliasFields')) {
        aliasFields = dot_prop_1.default.get(config, 'resolve.aliasFields');
    }
    else if (dot_prop_1.default.has(globalConfig, 'resolve.aliasFields')) {
        aliasFields = dot_prop_1.default.get(globalConfig, 'resolve.aliasFields');
    }
    else {
        aliasFields = ['browser'];
    }
    return aliasFields;
}
exports.getAliasFields = getAliasFields;
/**
 * Get the type of an alias `from` field (left hand side of alias)
 */
function getAliasFromType(from) {
    if (from.startsWith('/') || from.startsWith('.') || from.startsWith('..')) {
        return AliasFromType.LOCAL;
    }
    return AliasFromType.EXTERNAL;
}
exports.getAliasFromType = getAliasFromType;
/**
 * Get the type of an alias `to` field (right hand side of alias)
 */
function getAliasToType(to) {
    if (to === false) {
        return AliasToType.IGNORE;
    }
    if (to.startsWith('/')) {
        throw new Error(`Absolute paths in require() calls are not supported: ${to}`);
    }
    if (to.startsWith('.') || to.startsWith('..')) {
        return AliasToType.LOCAL;
    }
    return AliasToType.EXTERNAL;
}
exports.getAliasToType = getAliasToType;
/**
 * Load aliases from a `package.json` file.
 */
function loadAliases(pkgJsonFile, aliasFields) {
    const absPkgJsonFile = pkgJsonFile.resolve();
    const cacheKey = `${absPkgJsonFile.asNative}|${aliasFields.join()}`;
    let aliases = aliasesCache[cacheKey];
    // If not yet cached proceed
    if (aliases === undefined) {
        const pkgJson = safeReadJsonSync(absPkgJsonFile);
        aliases = aliasFields.reduce((aliases, aliasField) => {
            const aliasConfig = pkgJson[aliasField];
            if (aliasConfig === undefined) {
                return aliases;
            }
            if (aliasConfig === false || typeof aliasConfig === 'string') {
                let main = pkgJson['main'] || './index.js';
                if (!main.startsWith('.')) {
                    main = `./${main}`;
                }
                aliases[main] = aliasConfig;
            }
            else {
                Object.entries(aliasConfig).forEach(([from, to]) => {
                    aliases[from] = to;
                });
            }
            return aliases;
        }, {});
        // Normalize `/` to `./`
        Object.keys(aliases).forEach((key) => {
            if (key.startsWith('/')) {
                aliases[`.${key}`] = aliases[key];
                delete aliases[key];
            }
        });
        // Normalize local aliases to make them start with `./`
        Object.keys(aliases).forEach((key) => {
            if (key.startsWith('.')) {
                const value = aliases[key];
                if (typeof value === 'string' && !value.startsWith('.')) {
                    aliases[key] = `./${value}`;
                }
            }
        });
    }
    // Store in cache
    aliasesCache[cacheKey] = Object.assign(Object.create(null), aliases);
    return aliases;
}
exports.loadAliases = loadAliases;
function safeReadJsonSync(pkgJsonFile) {
    try {
        return read_json_sync_1.default(pkgJsonFile.asNative);
    }
    catch (err) {
        // Always return some sort of JSON if reading the file fails
        return {};
    }
}
