'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Â© 2017 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _clone = require('clone');

var _clone2 = _interopRequireDefault(_clone);

var _filePath = require('../file-path');

var _filePath2 = _interopRequireDefault(_filePath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Implements a restricted subset of  webpack rules specification. The rules are
 * specified as a top level field in `.npmbundlerrc`. Its supported structure
 * is:
 *
 * rules := [<rule>]
 * rule := {
 * 	 test: <test>,
 *   include: <include>,
 *   exclude: <exclude>,
 *   use: (<use> | [<use>])
 * }
 * test := (<regexp> | [<regexp>])
 * include := (<regexp> | [<regexp>])
 * exclude := (<regexp> | [<regexp>])
 * regexp := STRING
 * use := {STRING | <use_with_options>}
 * use_with_options := {
 *   loader: STRING,
 *   options: OBJECT
 * }
 *
 * See https://webpack.js.org/configuration/module/#modulerules for webpack's
 * specification.
 */
var Rules = function () {
	/**
  *
  * @param {Project} project
  */
	function Rules(project) {
		_classCallCheck(this, Rules);

		this._project = project;

		var _npmbundlerrc = project._npmbundlerrc;


		this._config = _npmbundlerrc.rules || [];

		this._rules = (0, _clone2.default)(this._config);
		this._normalizeRules();

		this._loaderVersionsInfo = undefined;
	}

	/**
  * Get raw rules config (useful for reports).
  */


	_createClass(Rules, [{
		key: 'loadersForFile',


		/**
   * Returns the associated rules for a given absolute file path.
   * @param {string} prjRelPath a native file path relative to
   * 						`project.dir`
   * @return {Array<object>} an Array of objects with structure
   * 				`{use, resolvedModule, exec, options}`
   */
		value: function loadersForFile(prjRelPath) {
			var _this = this,
			    _ref;

			var _rules = this._rules;


			var rules = _rules.filter(function (rule) {
				return _this._ruleApplies(rule, new _filePath2.default(prjRelPath));
			});

			var loaders = rules.map(function (rule) {
				return rule.use;
			});

			// Flatten array
			return (_ref = []).concat.apply(_ref, _toConsumableArray(loaders));
		}
	}, {
		key: '_instantiateLoader',
		value: function _instantiateLoader(use) {
			var project = this._project;

			try {
				use.resolvedModule = 'liferay-npm-bundler-loader-' + use.loader;
				use.exec = project.require(use.resolvedModule);
			} catch (err) {
				use.resolvedModule = use.loader;
				use.exec = project.require(use.resolvedModule);
			}

			use.exec = use.exec.default || use.exec;

			if (typeof use.exec !== 'function') {
				throw new Error('Loader \'' + use.resolvedModule + '\' is incorrect: ' + 'it does not export a function');
			}

			return use;
		}
	}, {
		key: '_normalizeRules',
		value: function _normalizeRules() {
			var _this2 = this;

			this._rules.forEach(function (rule) {
				_this2._normalizeArrayOfRegExp(rule, 'test', '.*');
				_this2._normalizeArrayOfRegExp(rule, 'include', '.*');
				_this2._normalizeArrayOfRegExp(rule, 'exclude', '(?!)');

				if (!Array.isArray(rule.use)) {
					rule.use = [rule.use];
				}

				rule.use = rule.use.map(function (use) {
					if (typeof use === 'string') {
						use = {
							loader: use
						};
					}

					if (use.options === undefined) {
						use.options = {};
					}

					use = _this2._instantiateLoader(use);

					return use;
				});
			});
		}
	}, {
		key: '_normalizeArrayOfRegExp',
		value: function _normalizeArrayOfRegExp(rule, fieldName, defaultValue) {
			if (rule[fieldName] === undefined) {
				rule[fieldName] = [defaultValue];
			} else if (typeof rule[fieldName] === 'string') {
				rule[fieldName] = [rule[fieldName]];
			} else if (!Array.isArray(rule[fieldName])) {
				throw new Error('Invalid rule ' + fieldName + ': ' + rule[fieldName]);
			}

			rule[fieldName] = rule[fieldName].map(function (test) {
				return new RegExp(test);
			});
		}

		/**
   *
   * @param {object} rule
   * @param {FilePath} prjRelFile
   */

	}, {
		key: '_ruleApplies',
		value: function _ruleApplies(rule, prjRelFile) {
			var matched = rule.test.find(function (regexp) {
				return regexp.test(prjRelFile.asPosix);
			});

			if (!matched) {
				return false;
			}

			var included = rule.include.find(function (regexp) {
				return regexp.test(prjRelFile.asPosix);
			});

			if (!included) {
				return false;
			}

			var excluded = rule.exclude.find(function (regexp) {
				return regexp.test(prjRelFile.asPosix);
			});

			if (excluded) {
				return false;
			}

			return true;
		}
	}, {
		key: 'config',
		get: function get() {
			return this._config;
		}

		/**
   * Get an object with information about all plugin versions
   * @return {object}
   */

	}, {
		key: 'loaderVersionsInfo',
		get: function get() {
			if (this._loaderVersionsInfo === undefined) {
				var _ref2;

				var loaders = this._rules.map(function (rule) {
					return rule.use;
				});

				loaders = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(loaders));

				var loaderPackages = loaders.map(function (loader) {
					var resolvedModule = loader.resolvedModule;

					return resolvedModule.split('/')[0];
				});

				var project = this._project;

				this._loaderVersionsInfo = loaderPackages.reduce(function (map, pkg) {
					var pkgJson = project.require(pkg + '/package.json');
					map[pkg] = pkgJson.version;
					return map;
				}, {});
			}

			return this._loaderVersionsInfo;
		}
	}]);

	return Rules;
}();

exports.default = Rules;
//# sourceMappingURL=rules.js.map