"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBundlerPluginDescriptors = exports.getPackageConfig = exports.getFeaturesFilePath = void 0;
const dot_prop_1 = __importDefault(require("dot-prop"));
const fs_1 = __importDefault(require("fs"));
const file_path_1 = __importDefault(require("../file-path"));
const modules_1 = require("../modules");
/**
 *
 * @param project
 * @param featuresKey
 * @param defaultPrjRelPosixPath a posix path relative to project root
 * @return absolute path to features file
 */
function getFeaturesFilePath(project, featuresKeyPath, defaultPrjRelPosixPath) {
    const { dir: projectDir, npmbundlerrc } = project;
    const prjRelPosixPath = dot_prop_1.default.get(npmbundlerrc, featuresKeyPath);
    if (prjRelPosixPath !== undefined) {
        return projectDir.join(new file_path_1.default(prjRelPosixPath, { posix: true }))
            .asNative;
    }
    const defaultAbsPath = projectDir.join(new file_path_1.default(defaultPrjRelPosixPath, { posix: true })).asNative;
    if (fs_1.default.existsSync(defaultAbsPath)) {
        return defaultAbsPath;
    }
    return undefined;
}
exports.getFeaturesFilePath = getFeaturesFilePath;
/**
 * Get a configuration for a specific package. This method looks in the packages
 * section, then at root in the precedence order: first package id, then package
 * name.
 *
 * @remarks
 * Returns different types depending on `section`
 *
 * @param project
 * @param pkg the package descriptor
 * @param section the section name (like 'plugins', '.babelrc', ...)
 * @param defaultValue default value if not configured
 */
function getPackageConfig(project, pkg, section, defaultValue = undefined) {
    let pkgConfig;
    const { npmbundlerrc } = project;
    if (npmbundlerrc['packages'] &&
        npmbundlerrc['packages'][pkg.id] &&
        npmbundlerrc['packages'][pkg.id][section]) {
        pkgConfig = npmbundlerrc['packages'][pkg.id][section];
    }
    else if (npmbundlerrc['packages'] &&
        npmbundlerrc['packages'][pkg.name] &&
        npmbundlerrc['packages'][pkg.name][section]) {
        pkgConfig = npmbundlerrc['packages'][pkg.name][section];
    }
    else if (npmbundlerrc['packages'] &&
        npmbundlerrc['packages']['*'] &&
        npmbundlerrc['packages']['*'][section]) {
        pkgConfig = npmbundlerrc['packages']['*'][section];
    }
    // Legacy configuration support
    else if (npmbundlerrc[pkg.id] && npmbundlerrc[pkg.id][section]) {
        pkgConfig = npmbundlerrc[pkg.id][section];
    }
    else if (npmbundlerrc[pkg.name] && npmbundlerrc[pkg.name][section]) {
        pkgConfig = npmbundlerrc[pkg.name][section];
    }
    else if (npmbundlerrc['*'] && npmbundlerrc['*'][section]) {
        pkgConfig = npmbundlerrc['*'][section];
    }
    else {
        pkgConfig = defaultValue;
    }
    return pkgConfig;
}
exports.getPackageConfig = getPackageConfig;
/**
 * Instantiate bundler plugins described by their names.
 * @param project
 * @param pkgConfig plugins configuration as extracted from .npmbundlerrc
 */
function createBundlerPluginDescriptors(project, pkgConfig) {
    return pkgConfig.map((pkgConfigItem) => {
        let pluginName;
        let pluginConfig;
        if (Array.isArray(pkgConfigItem)) {
            pluginName = pkgConfigItem[0];
            pluginConfig = pkgConfigItem[1];
        }
        else {
            pluginName = pkgConfigItem;
            pluginConfig = {};
        }
        const parts = modules_1.splitModuleName(pluginName);
        // If `pluginName` is a package prefix it with
        // `liferay-npm-bundler-plugin-`, otherwise use it directly
        let pluginModule = project.toolRequire(parts.modulePath
            ? pluginName
            : `liferay-npm-bundler-plugin-${pluginName}`);
        if (pluginModule.default !== undefined) {
            pluginModule = pluginModule.default;
        }
        return {
            name: pluginName,
            config: pluginConfig,
            run: pluginModule,
        };
    });
}
exports.createBundlerPluginDescriptors = createBundlerPluginDescriptors;
