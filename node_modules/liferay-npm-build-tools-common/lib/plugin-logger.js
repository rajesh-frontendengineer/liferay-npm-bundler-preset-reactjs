'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * An object to hold babel or liferay-npm-bundler plugin messages.
 * @type {PluginLogger}
 */
var PluginLogger = function () {
	/**
  * Construct empty logger with no messages
  */
	function PluginLogger() {
		_classCallCheck(this, PluginLogger);

		this._msgs = [];
	}

	/**
  * Log an informational message
  * @param {String} source the identifier for the source of the message
  * @param {Array} things the objects or strings to print
  * @return {void}
  */


	_createClass(PluginLogger, [{
		key: 'info',
		value: function info(source) {
			for (var _len = arguments.length, things = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				things[_key - 1] = arguments[_key];
			}

			this._msgs.push({
				source: source,
				level: 'info',
				things: things
			});
		}

		/**
   * Log a warn message
   * @param {String} source the identifier for the source of the message
   * @param {Array} things the objects or strings to print
   * @return {void}
   */

	}, {
		key: 'warn',
		value: function warn(source) {
			for (var _len2 = arguments.length, things = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				things[_key2 - 1] = arguments[_key2];
			}

			this._msgs.push({
				source: source,
				level: 'warn',
				things: things
			});
		}

		/**
   * Log an error message
   * @param {String} source the identifier for the source of the message
   * @param {Array} things the objects or strings to print
   * @return {void}
   */

	}, {
		key: 'error',
		value: function error(source) {
			for (var _len3 = arguments.length, things = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
				things[_key3 - 1] = arguments[_key3];
			}

			this._msgs.push({
				source: source,
				level: 'error',
				things: things
			});
		}

		/**
   * Get the list of messages
   * @return {Array} an array containing one object per messages (with fields: source, level and things)
   */

	}, {
		key: 'toString',


		/**
   * Return a printable string representation of the messages logged till now
   * @return {String} a string containing one line per message
   */
		value: function toString() {
			return this._msgs.reduce(function (str, _ref) {
				var level = _ref.level,
				    source = _ref.source,
				    things = _ref.things;
				return '' + str + source + ':' + level + ': ' + things.join(' ') + '\n';
			}, '');
		}

		/**
   * Return an HTML string representation of the messages logged till now
   * @return {String} HTML containing one line (<br> separated) per message
   */

	}, {
		key: 'toHtml',
		value: function toHtml() {
			return this._msgs.reduce(function (str, _ref2) {
				var level = _ref2.level,
				    source = _ref2.source,
				    things = _ref2.things;
				return '' + str + source + ':' + level + ': ' + things.join(' ') + '<br>';
			}, '');
		}
	}, {
		key: 'messages',
		get: function get() {
			return this._msgs;
		}

		/**
   * Test if there are warn messages.
   * @return {boolean} if at least one warn message is registered in the logger
   */

	}, {
		key: 'warnsPresent',
		get: function get() {
			return this._msgs.filter(function (msg) {
				return msg.level === 'warn';
			}).length > 0;
		}

		/**
   * Test if there are error messages.
   * @return {boolean} if at least one error message is registered in the logger
   */

	}, {
		key: 'errorsPresent',
		get: function get() {
			return this._msgs.filter(function (msg) {
				return msg.level === 'error';
			}).length > 0;
		}
	}]);

	return PluginLogger;
}();

exports.default = PluginLogger;
//# sourceMappingURL=plugin-logger.js.map