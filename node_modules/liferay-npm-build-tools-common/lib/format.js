'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.error = error;
exports.info = info;
exports.print = print;
exports.success = success;
exports.question = question;
exports.title = title;
exports.warn = warn;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Formatting options may be added by setting the `LR_FORMAT_OPTS` environment
 * variable. It is supposed to be a comma separated list of options.
 *
 * Valid options are:
 *
 *   * `no-colors`: don't use colors for texts
 *   * `no-decorations`: don't use font decorations or emojis
 *
 */
var lrFormatOpts = (process.env['LR_FORMAT_OPTS'] || '').split(','); /**
                                                                      * © 2017 Liferay, Inc. <https://liferay.com>
                                                                      *
                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                      */

var opts = {
  noColors: lrFormatOpts.indexOf('no-colors') != -1,
  noDecorations: lrFormatOpts.indexOf('no-decorations') != -1
};

var verbatim = function verbatim() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.join(' ');
};
var fmt = {
  bold: opts.noDecorations ? verbatim : _chalk2.default.bold,
  error: opts.noColors ? verbatim : _chalk2.default.hex('#F44'),
  info: opts.noColors ? verbatim : _chalk2.default.hex('#888'),
  question: opts.noColors ? verbatim : _chalk2.default.hex('#55F'),
  success: opts.noColors ? verbatim : _chalk2.default.hex('#0A0'),
  title: opts.noColors ? verbatim : _chalk2.default.bold.hex('#55F'),
  underline: opts.noDecorations ? verbatim : _chalk2.default.underline,
  warn: opts.noColors ? verbatim : _chalk2.default.hex('#CA0')
};

function error(literals) {
  for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    values[_key2 - 1] = arguments[_key2];
  }

  return fmt.error(format('❌', literals, values));
}

function info(literals) {
  for (var _len3 = arguments.length, values = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    values[_key3 - 1] = arguments[_key3];
  }

  return fmt.info(format('ℹ️', literals, values));
}

/**
 * Print an array of lines separating them with CRs or a single line.
 *
 * It takes care of removing:
 *
 *   * Words inside `||` if `no-decorations` option is set
 *
 * And also decorates (unless `no-decorations` is provided):
 *
 *   * URLs starting with `http(s)://` with underline
 *   * Words inside `{}` with bold
 *
 * Each passed line is processed by the `removeJsFormatWhitespace` function.
 *
 * @param {Array|string} lines
 */
function print(lines) {
  if (!Array.isArray(lines)) {
    lines = [lines];
  }

  lines = lines.map(function (line) {
    line = removeJsFormatWhitespace(line);

    line = line.replace(/(https?:\/\/[^\s]+)/gm, fmt.underline('$1'));
    line = line.replace(/{([^}]*)}/gm, fmt.bold('$1'));
    line = line.replace(/\|([^|]*)\|/g, opts.noDecorations ? '' : '$1');

    return line;
  });

  console.log(lines.join('\n'));
}

function success(literals) {
  for (var _len4 = arguments.length, values = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    values[_key4 - 1] = arguments[_key4];
  }

  return fmt.success(format('✔️', literals, values));
}

function question(literals) {
  for (var _len5 = arguments.length, values = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    values[_key5 - 1] = arguments[_key5];
  }

  return fmt.question(format('❓', literals, values));
}

function title(literals) {
  for (var _len6 = arguments.length, values = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    values[_key6 - 1] = arguments[_key6];
  }

  return fmt.title(format('', literals, values));
}

function warn(literals) {
  for (var _len7 = arguments.length, values = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    values[_key7 - 1] = arguments[_key7];
  }

  return fmt.warn(format('⚠️', literals, values));
}

/**
 * This is an ES6 template unrolling function that optionally prefixes the final
 * string with an emoji.
 *
 * The emoji is treated as a decoration and thus removed if the `no-decorations`
 * option is set.
 *
 * The resulting string is processed by the `removeJsFormatWhitespace` function.
 *
 * @param {string} emoji an emoji or an empty string to prefix the text
 * @param {Array<string>} literals
 * @param  {...any} values
 */
function format(emoji, literals) {
  var ret = literals[0];

  for (var _len8 = arguments.length, values = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
    values[_key8 - 2] = arguments[_key8];
  }

  for (var i = 0; i < values.length; i++) {
    ret += values[i];

    if (i + 1 < literals.length) {
      ret += literals[i + 1];
    }
  }

  ret = removeJsFormatWhitespace(ret);
  ret = (emoji ? '|' + emoji + ' |' : '') + ret;

  return ret;
}

/**
 * This function removes:
 *
 *   * A leading CR in the first line if it exists
 *   * Two tabs at the begining of each line
 *
 * This is to enhance legibility of JS code when it is formatted according to
 * the project's rules.
 *
 * This function is (and must always be) idempotent because it may need to be
 * applied several times to the same line.
 * @param {string} line
 */
function removeJsFormatWhitespace(line) {
  line = line.replace(/^\n/, '');
  line = line.replace(/^\t\t/gm, '');

  return line;
}
//# sourceMappingURL=format.js.map