'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getPackageJsonPath = getPackageJsonPath;
exports.getPackageDir = getPackageDir;
exports.getPackageTargetDir = getPackageTargetDir;
exports.resolveModuleFile = resolveModuleFile;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync2 = require('read-json-sync');

var _readJsonSync3 = _interopRequireDefault(_readJsonSync2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * Â© 2017 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                     */

var packageDirCache = {};

/**
 * Get the full path of the package.json file for a given JS module file.
 * @param {String} modulePath the relative or absolute path to a JS module file
 * @return {String} the full path to the package.json file (with native path
 *         separators)
 */
function getPackageJsonPath(modulePath) {
	return _path2.default.join(getPackageDir(modulePath), 'package.json');
}

/**
 * Get the full path of the package directory for a given JS module file.
 * @param {String} modulePath the relative or absolute path to a JS module file
 * @return {String} the full path to the package directory (with native path
 *         separators)
 */
function getPackageDir(modulePath) {
	var absModulePath = _path2.default.resolve(modulePath);
	var dir = packageDirCache[absModulePath];

	if (!dir) {
		dir = absModulePath;
		var found = false;

		while (!found) {
			try {
				var pkgJsonPath = _path2.default.join(dir, 'package.json');

				_fs2.default.statSync(pkgJsonPath);

				var _readJsonSync = (0, _readJsonSync3.default)(pkgJsonPath),
				    version = _readJsonSync.version;

				if (version === undefined) {
					throw new Error('No valid version field found');
				}

				found = true;
			} catch (err) {
				var dirname = _path2.default.dirname(dir);

				if (dirname == dir) {
					throw new Error('Cannot find package.json for file: ' + modulePath);
				}

				dir = dirname;
			}
		}

		packageDirCache[absModulePath] = dir;
	}

	return dir;
}

/**
 * Converts a package name (optionally versioned) to its target folder name
 * inside bundled node_modules.
 * @param  {String} name a package name
 * @param  {String} [version=null] an optional package version
 * @return {String} the target folder
 */
function getPackageTargetDir(name) {
	var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	var targetFolder = name.replace('/', '%2F');

	if (version) {
		targetFolder += '@' + version;
	}

	return targetFolder;
}

/**
 * Resolves a module name inside a package directory to a file relative (to
 * package directory) path.
 * For example, if you pass './lib' as moduleName and there's an 'index.js' file
 * inside the 'lib' dir, the method returns './lib/index.js'.
 * It also honors any 'package.json' with a 'main' entry in package subfolders.
 * @param  {String} pkgPath path to package directory
 * @param  {String} moduleName the module name
 * @return {String} a path relative to pkgDir
 */
function resolveModuleFile(pkgPath, moduleName) {
	var fullModulePath = _path2.default.resolve(_path2.default.join.apply(_path2.default, [pkgPath].concat(_toConsumableArray(moduleName.split('/')))));
	var moduleStats = safeStat(fullModulePath);

	if (moduleStats.isDirectory()) {
		// Given module name is a directory
		var pkgJsonPath = _path2.default.join(fullModulePath, 'package.json');
		var pkgJsonStats = safeStat(pkgJsonPath);

		if (pkgJsonStats.isFile()) {
			// Module directory has package.json file
			var pkgJson = (0, _readJsonSync3.default)(pkgJsonPath);
			var main = pkgJson.main;


			if (main) {
				// Module directory has package.json file with main entry:
				// recursively resolve the main entry's file path
				fullModulePath = _path2.default.join(pkgPath, resolveModuleFile(pkgPath, _path2.default.join(moduleName, main)));
			} else {
				// Module directory has package.json file without main entry:
				// assume index.js
				fullModulePath = _path2.default.join(fullModulePath, 'index.js');
			}
		} else {
			// Module directory has not package.json file: assume index.js
			fullModulePath = _path2.default.join(fullModulePath, 'index.js');
		}
	} else if (moduleStats.isFile()) {
		// Given module name is a file: do nothing
	} else if (fullModulePath.endsWith('.js')) {
		// Given module name is not a directory nor a file but ends with '.js'
		// extension: see if corresponding '.js.js' file exists
		moduleStats = safeStat(fullModulePath + '.js');

		if (moduleStats.isFile()) {
			// Given module name has a corresponding '.js.js' file: add '.js'
			// extension
			fullModulePath += '.js';
		} else {
			// Given module name has no corresponding '.js.js' file: do nothing
			// and assume that the '.js' in the module name is just the
			// extension of the file and doesn't belong to its name.
		}
	} else {
		// Given module name is not a directory nor a file and doesn't end with
		// '.js' extension: add '.js' extension
		fullModulePath += '.js';
	}

	return _path2.default.relative(pkgPath, fullModulePath);
}

/**
 * Do as fs.statSync without throwing errors.
 * @param  {String} path path to check
 * @return {fs.Stats} a real fs.Stats object or a null object
 */
function safeStat(path) {
	try {
		return _fs2.default.statSync(path);
	} catch (err) {
		return {
			isDirectory: function isDirectory() {
				return false;
			},
			isFile: function isFile() {
				return false;
			}
		};
	}
}
//# sourceMappingURL=packages.js.map