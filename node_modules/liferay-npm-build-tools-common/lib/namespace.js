'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isNamespaced = isNamespaced;
exports.addNamespace = addNamespace;
exports.removeNamespace = removeNamespace;
exports.getNamespace = getNamespace;
exports.makeNamespace = makeNamespace;

var _modules = require('./modules');

var mod = _interopRequireWildcard(_modules);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Test if a module name is namespaced according to any root package.
 * @param {String} moduleName a module name
 * @return {Boolean} true if the module is namespaced
 */
function isNamespaced(moduleName) {
	return getNamespace(moduleName) != null;
}

/**
 * Namespace a module name according to some root package name. If the module
 * name is already namespaced with a different root package, an Error is thrown.
 * If the module is local it is left untouched.
 * @param {String} moduleName a module name
 * @param {String} name name of root package
 * @param {Boolean} allowOverride don't fail when trying to change the namespace
 * @return {String} the namespaced module name
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function addNamespace(moduleName, _ref) {
	var name = _ref.name;

	var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	    _ref2$allowOverride = _ref2.allowOverride,
	    allowOverride = _ref2$allowOverride === undefined ? false : _ref2$allowOverride;

	var moduleNamespace = getNamespace(moduleName);
	var namespace = makeNamespace({ name: name });

	if (moduleNamespace != null) {
		if (moduleNamespace !== namespace) {
			if (!allowOverride) {
				throw new Error('Current moduleName namespace (' + moduleNamespace + ') ' + (' and given one (' + namespace + ') don\'t match'));
			} else {
				moduleName = removeNamespace(moduleName);
			}
		} else {
			return moduleName;
		}
	}

	if (mod.isLocalModule(moduleName)) {
		return moduleName;
	} else if (moduleName.startsWith(name + '/') || moduleName === name) {
		return moduleName;
	} else if (moduleName.startsWith('@')) {
		return moduleName.replace('@', '@' + namespace);
	} else {
		return namespace + moduleName;
	}
}

/**
 * Remove namespace from a module name if present, otherwise leave it untouched.
 * @param {String} moduleName a module name
 * @return {String} the un-namespaced module name
 */
function removeNamespace(moduleName) {
	var namespace = getNamespace(moduleName);

	if (namespace != null) {
		if (moduleName.startsWith('@')) {
			return moduleName.replace('@' + namespace, '@');
		} else {
			return moduleName.substring(namespace.length);
		}
	}

	return moduleName;
}

/**
 * Returns the namespace of a given moduleName or null if module name is not
 * namespaced.
 * @param {String} moduleName a module name
 * @return {String} the namespace of the module name or null
 */
function getNamespace(moduleName) {
	var parts = moduleName.split('$');

	if (parts.length >= 2 && !parts[0].includes('/')) {
		if (parts[0].startsWith('@')) {
			return parts[0].substring(1) + '$';
		} else {
			return parts[0] + '$';
		}
	}

	return null;
}

/**
 * Compose the namespace of a module according to some root package name.
 * @param {String} name name of root package
 * @return {String} the namespace for modules
 */
function makeNamespace(_ref3) {
	var name = _ref3.name;

	return name + '$';
}
//# sourceMappingURL=namespace.js.map