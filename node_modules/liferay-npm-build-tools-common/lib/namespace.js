"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeNamespace = exports.getNamespace = exports.removeNamespace = exports.addNamespace = exports.isNamespaced = void 0;
const mod = __importStar(require("./modules"));
/**
 * Test if a module name is namespaced according to any root package.
 * @param moduleName a module name
 * @return true if the module is namespaced
 */
function isNamespaced(moduleName) {
    const nameSpace = getNamespace(moduleName);
    return nameSpace !== null && nameSpace !== undefined;
}
exports.isNamespaced = isNamespaced;
/**
 * Namespace a module name according to some root package name. If the module
 * name is already namespaced with a different root package, an Error is thrown.
 * If the module is local it is left untouched.
 * @param moduleName a module name
 * @param name name of root package
 * @param allowOverride don't fail when trying to change the namespace
 * @return the namespaced module name
 */
function addNamespace(moduleName, { name }, { allowOverride = false } = {}) {
    const moduleNamespace = getNamespace(moduleName);
    const namespace = makeNamespace({ name });
    if (moduleNamespace !== null) {
        if (moduleNamespace !== namespace) {
            if (!allowOverride) {
                throw new Error(`Current moduleName namespace (${moduleNamespace}) ` +
                    ` and given one (${namespace}) don't match`);
            }
            else {
                moduleName = removeNamespace(moduleName);
            }
        }
        else {
            return moduleName;
        }
    }
    if (mod.isLocalModule(moduleName)) {
        return moduleName;
    }
    else if (moduleName.startsWith(`${name}/`) || moduleName === name) {
        return moduleName;
    }
    else if (moduleName.startsWith('@')) {
        return moduleName.replace('@', `@${namespace}`);
    }
    else {
        return namespace + moduleName;
    }
}
exports.addNamespace = addNamespace;
/**
 * Remove namespace from a module name if present, otherwise leave it untouched.
 * @param moduleName a module name
 * @return the un-namespaced module name
 */
function removeNamespace(moduleName) {
    const namespace = getNamespace(moduleName);
    if (namespace !== null && namespace !== undefined) {
        if (moduleName.startsWith('@')) {
            return moduleName.replace(`@${namespace}`, '@');
        }
        else {
            return moduleName.substring(namespace.length);
        }
    }
    return moduleName;
}
exports.removeNamespace = removeNamespace;
/**
 * Returns the namespace of a given moduleName or null if module name is not
 * namespaced.
 * @param moduleName a module name
 * @return the namespace of the module name or null
 */
function getNamespace(moduleName) {
    const parts = moduleName.split('$');
    if (parts.length >= 2 && !parts[0].includes('/')) {
        if (parts[0].startsWith('@')) {
            return parts[0].substring(1) + '$';
        }
        else {
            return parts[0] + '$';
        }
    }
    return null;
}
exports.getNamespace = getNamespace;
/**
 * Compose the namespace of a module according to some root package name.
 * @param name name of root package
 * @return the namespace for modules
 */
function makeNamespace({ name }) {
    // Convert `@liferay/frontend-js-web` to `liferay!frontend-js-web`.
    //
    // `/` would confuse the legacy AMD code and would break backward
    // compatibility, so we need to pick a substitute that is legal in URLs and
    // filesystems, but not allowed in npm package names (to avoid collisions
    // with valid non-scoped package names).
    //
    // We use ! for scopes in the namespacing package, and $ for scopes in the
    // namespaced package so that it is easier to understand and parse.
    if (name.startsWith('@')) {
        name = name.substr(1).replace('/', '!');
    }
    return name + '$';
}
exports.makeNamespace = makeNamespace;
