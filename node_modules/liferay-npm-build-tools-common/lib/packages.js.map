{"version":3,"sources":["../src/packages.js"],"names":["getPackageJsonPath","getPackageDir","getPackageTargetDir","resolveModuleFile","packageDirCache","modulePath","path","join","absModulePath","resolve","dir","found","pkgJsonPath","fs","statSync","version","undefined","Error","err","dirname","name","targetFolder","replace","pkgPath","moduleName","fullModulePath","split","moduleStats","safeStat","isDirectory","pkgJsonStats","isFile","pkgJson","main","endsWith","relative"],"mappings":"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","file":"packages.js","sourcesContent":["/**\n * Â© 2017 Liferay, Inc. <https://liferay.com>\n *\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport readJsonSync from 'read-json-sync';\n\nconst packageDirCache = {};\n\n/**\n * Get the full path of the package.json file for a given JS module file.\n * @param {String} modulePath the relative or absolute path to a JS module file\n * @return {String} the full path to the package.json file (with native path\n *         separators)\n */\nexport function getPackageJsonPath(modulePath) {\n\treturn path.join(getPackageDir(modulePath), 'package.json');\n}\n\n/**\n * Get the full path of the package directory for a given JS module file.\n * @param {String} modulePath the relative or absolute path to a JS module file\n * @return {String} the full path to the package directory (with native path\n *         separators)\n */\nexport function getPackageDir(modulePath) {\n\tconst absModulePath = path.resolve(modulePath);\n\tlet dir = packageDirCache[absModulePath];\n\n\tif (!dir) {\n\t\tdir = absModulePath;\n\t\tlet found = false;\n\n\t\twhile (!found) {\n\t\t\ttry {\n\t\t\t\tconst pkgJsonPath = path.join(dir, 'package.json');\n\n\t\t\t\tfs.statSync(pkgJsonPath);\n\n\t\t\t\tconst {version} = readJsonSync(pkgJsonPath);\n\n\t\t\t\tif (version === undefined) {\n\t\t\t\t\tthrow new Error('No valid version field found');\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\t\t\t} catch (err) {\n\t\t\t\tconst dirname = path.dirname(dir);\n\n\t\t\t\tif (dirname == dir) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot find package.json for file: ' + modulePath\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdir = dirname;\n\t\t\t}\n\t\t}\n\n\t\tpackageDirCache[absModulePath] = dir;\n\t}\n\n\treturn dir;\n}\n\n/**\n * Converts a package name (optionally versioned) to its target folder name\n * inside bundled node_modules.\n * @param  {String} name a package name\n * @param  {String} [version=null] an optional package version\n * @return {String} the target folder\n */\nexport function getPackageTargetDir(name, version = null) {\n\tlet targetFolder = name.replace('/', '%2F');\n\n\tif (version) {\n\t\ttargetFolder += `@${version}`;\n\t}\n\n\treturn targetFolder;\n}\n\n/**\n * Resolves a module name inside a package directory to a file relative (to\n * package directory) path.\n * For example, if you pass './lib' as moduleName and there's an 'index.js' file\n * inside the 'lib' dir, the method returns './lib/index.js'.\n * It also honors any 'package.json' with a 'main' entry in package subfolders.\n * @param  {String} pkgPath path to package directory\n * @param  {String} moduleName the module name\n * @return {String} a path relative to pkgDir\n */\nexport function resolveModuleFile(pkgPath, moduleName) {\n\tlet fullModulePath = path.resolve(\n\t\tpath.join(pkgPath, ...moduleName.split('/'))\n\t);\n\tlet moduleStats = safeStat(fullModulePath);\n\n\tif (moduleStats.isDirectory()) {\n\t\t// Given module name is a directory\n\t\tconst pkgJsonPath = path.join(fullModulePath, 'package.json');\n\t\tconst pkgJsonStats = safeStat(pkgJsonPath);\n\n\t\tif (pkgJsonStats.isFile()) {\n\t\t\t// Module directory has package.json file\n\t\t\tconst pkgJson = readJsonSync(pkgJsonPath);\n\t\t\tconst {main} = pkgJson;\n\n\t\t\tif (main) {\n\t\t\t\t// Module directory has package.json file with main entry:\n\t\t\t\t// recursively resolve the main entry's file path\n\t\t\t\tfullModulePath = path.join(\n\t\t\t\t\tpkgPath,\n\t\t\t\t\tresolveModuleFile(pkgPath, path.join(moduleName, main))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Module directory has package.json file without main entry:\n\t\t\t\t// assume index.js\n\t\t\t\tfullModulePath = path.join(fullModulePath, 'index.js');\n\t\t\t}\n\t\t} else {\n\t\t\t// Module directory has not package.json file: assume index.js\n\t\t\tfullModulePath = path.join(fullModulePath, 'index.js');\n\t\t}\n\t} else if (moduleStats.isFile()) {\n\t\t// Given module name is a file: do nothing\n\t} else if (fullModulePath.endsWith('.js')) {\n\t\t// Given module name is not a directory nor a file but ends with '.js'\n\t\t// extension: see if corresponding '.js.js' file exists\n\t\tmoduleStats = safeStat(`${fullModulePath}.js`);\n\n\t\tif (moduleStats.isFile()) {\n\t\t\t// Given module name has a corresponding '.js.js' file: add '.js'\n\t\t\t// extension\n\t\t\tfullModulePath += '.js';\n\t\t} else {\n\t\t\t// Given module name has no corresponding '.js.js' file: do nothing\n\t\t\t// and assume that the '.js' in the module name is just the\n\t\t\t// extension of the file and doesn't belong to its name.\n\t\t}\n\t} else {\n\t\t// Given module name is not a directory nor a file and doesn't end with\n\t\t// '.js' extension: add '.js' extension\n\t\tfullModulePath += '.js';\n\t}\n\n\treturn path.relative(pkgPath, fullModulePath);\n}\n\n/**\n * Do as fs.statSync without throwing errors.\n * @param  {String} path path to check\n * @return {fs.Stats} a real fs.Stats object or a null object\n */\nfunction safeStat(path) {\n\ttry {\n\t\treturn fs.statSync(path);\n\t} catch (err) {\n\t\treturn {\n\t\t\tisDirectory: () => false,\n\t\t\tisFile: () => false,\n\t\t};\n\t}\n}\n"]}